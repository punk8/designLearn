//new 对象的过程
//1. 给 singleton 分配内存
//2. 调用 Singleton 的构造函数来初始化成员变量，形成实例
//3. 将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null了）
//正常情况下应该是 1-2-3 但由于指令重排的可能可能会出现1-3-2 在执行3时 若此时其他线程进入第一个判断 实际上instance已经不为null但是仍没有完成初始化 所以会报错
//volatile关键字的一个作用是禁止指令重排，把instance声明为volatile之后，对它的写操作就会有一个内存屏障



不能抵抗反射攻击
饿汉模式 线程安全 但浪费内存
懒汉模式 线程不安全
双重检测模式 + volatile 线程安全
static内部类返回单例 只有在调用时被加载 实现了延迟加载 这个static 还未创建对象 所以也不占据内存


抵抗反射攻击
枚举单例


